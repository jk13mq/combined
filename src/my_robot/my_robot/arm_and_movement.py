#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from servo_controller_msgs.msg import ServosPosition, ServoPosition
import time
import json
import os

class RobotController(Node):
    """
    A ROS2 node that combines arm and robot movement control with safety features.
    This class provides methods to control both the robotic arm and the robot's base movement
    with guaranteed return-to-safe-position after each movement.
    Input: JSON commands from music generation
    Output: Publishes commands to both servo controller and cmd_vel topics
    """
    
    def __init__(self):
        super().__init__('robot_controller')
        
        # Create publishers for both arm and movement
        self.arm_publisher = self.create_publisher(ServosPosition, 'servo_controller', 10)
        self.movement_publisher = self.create_publisher(Twist, '/cmd_vel', 10)
        
        # Define positions
        self.home_position = {
            1: 500,  # Base joint
            2: 500,  # Shoulder joint
            3: 500,  # Elbow joint
            4: 500,  # Wrist joint
            5: 500,  # Wrist rotation
            6: 500   # Gripper
        }
        
        self.fold_position = {
            1: 500,  # Base rotation
            2: 250,  # Shoulder down
            3: 300,  # Elbow in
            4: 300,  # Wrist curled
            5: 500,  # Wrist rotation
            6: 200   # Gripper closed
        }
        
        self.raised_position = {
            1: 500,  # Base rotation
            2: 700,  # Shoulder up
            3: 700,  # Elbow up
            4: 500,  # Wrist straight
            5: 500,  # Wrist rotation
            6: 500   # Gripper open
        }
        
        self.get_logger().info('Robot controller initialized')

    def move_arm(self, joint_positions: dict, duration: float = 1.0):
        """
        Move multiple arm joints simultaneously
        
        Args:
            joint_positions (dict): Dictionary mapping joint IDs to their target positions
            duration (float): Time in seconds for the movement to complete
        """
        msg = ServosPosition()
        msg.position_unit = 'pulse'
        msg.duration = duration
        
        for joint_id, position in joint_positions.items():
            servo = ServoPosition()
            # Convert joint_id to integer
            servo.id = int(joint_id)
            servo.position = float(position)
            msg.position.append(servo)
            
        self.arm_publisher.publish(msg)
        self.get_logger().info(f"Moving arm joints: {joint_positions}")

    def safe_move_robot(self, linear_speed: float, angular_speed: float, duration: float):
        """
        Move the robot base and immediately return to original position
        Duration is automatically limited to 0.5 seconds maximum
        
        Args:
            linear_speed (float): Forward/backward speed in m/s
            angular_speed (float): Rotational speed in rad/s
            duration (float): Time to move in seconds (capped at 0.5s)
        """
        # Cap duration at 0.5 seconds
        duration = min(duration, 0.5)
        
        # Forward movement
        twist = Twist()
        twist.linear.x = linear_speed
        twist.angular.z = angular_speed
        
        end_time = time.time() + duration
        while time.time() < end_time and rclpy.ok():
            self.movement_publisher.publish(twist)
            time.sleep(0.1)
        
        # Immediate return movement
        twist.linear.x = -linear_speed
        twist.angular.z = -angular_speed
        
        end_time = time.time() + duration
        while time.time() < end_time and rclpy.ok():
            self.movement_publisher.publish(twist)
            time.sleep(0.1)
        
        # Stop the robot
        twist.linear.x = 0.0
        twist.angular.z = 0.0
        self.movement_publisher.publish(twist)
        self.get_logger().info(f"Robot movement complete: linear={linear_speed}, angular={angular_speed}")

    def execute_dance_from_json(self, json_file: str, start_delay: int = 3):
        """
        Execute dance movements from a JSON file generated by music analysis
        
        Args:
            json_file (str): Path to the JSON file containing dance commands
            start_delay (int): Delay in seconds before starting the dance
        """
        try:
            # Load JSON commands
            with open(json_file, 'r') as f:
                commands = json.load(f)
            
            if not commands:
                self.get_logger().error("No commands found in JSON file")
                return
            
            self.get_logger().info(f"Starting dance sequence in {start_delay} seconds...")
            for i in range(start_delay, 0, -1):
                self.get_logger().info(f"{i}...")
                time.sleep(1)
            
            self.get_logger().info("DANCE STARTED!")
            start_time = time.time()
            
            # Execute each command
            for command in commands:
                target_time = start_time + command['timestamp']
                current_time = time.time()
                
                if current_time < target_time:
                    time.sleep(target_time - current_time)
                
                # Execute arm movement
                self.move_arm(command['arm_positions'], command['duration'])
                
                # Execute base movement
                if command['movement_type'] == 'forward':
                    self.safe_move_robot(0.2, 0.1, command['duration'])
                else:  # return movement
                    self.safe_move_robot(-0.2, -0.1, command['duration'])
                
                self.get_logger().info(
                    f"Executed {command['movement_pattern']} "
                    f"({command['movement_type']}) at {command['timestamp']:.1f}s"
                )
            
            # Return to home position
            self.move_arm(self.home_position)
            self.safe_move_robot(0.0, 0.0, 0.1)
            self.get_logger().info("Dance complete!")
            
        except FileNotFoundError:
            self.get_logger().error(f"JSON file not found: {json_file}")
        except json.JSONDecodeError:
            self.get_logger().error(f"Invalid JSON format in file: {json_file}")
        except KeyboardInterrupt:
            self.get_logger().info("Dance interrupted by user")
            # Ensure we return to home position
            self.move_arm(self.home_position)
            self.safe_move_robot(0.0, 0.0, 0.1)
        except Exception as e:
            self.get_logger().error(f"Error during dance: {str(e)}")
            # Ensure we return to home position
            self.move_arm(self.home_position)
            self.safe_move_robot(0.0, 0.0, 0.1)

def main(args=None):
    rclpy.init(args=args)
    node = RobotController()
    
    try:
        # Get the JSON file path from command line argument or use default
        import sys
        json_file = sys.argv[1] if len(sys.argv) > 1 else "jetrover_dance_commands.json"
        
        # Execute dance from JSON
        node.execute_dance_from_json(json_file)
        
    except Exception as e:
        node.get_logger().error(f'Error: {str(e)}')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()