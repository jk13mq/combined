#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from servo_controller_msgs.msg import ServosPosition, ServoPosition
import time
import json
import os
import pygame
import threading

class RobotController(Node):
    """
    A ROS2 node that combines arm and robot movement control with safety features.
    This class provides methods to control both the robotic arm and the robot's base movement
    with guaranteed return-to-safe-position after each movement.
    Input: JSON commands from music generation
    Output: Publishes commands to both servo controller and cmd_vel topics
    """
    
    def __init__(self):
        super().__init__('robot_controller')
        
        # Initialize pygame mixer for audio
        pygame.mixer.init()
        
        # Create publishers for both arm and movement
        self.arm_publisher = self.create_publisher(ServosPosition, 'servo_controller', 10)
        self.movement_publisher = self.create_publisher(Twist, '/cmd_vel', 10)
        
        # Define positions
        self.home_position = {
            1: 500,  # Base joint
            2: 500,  # Shoulder joint
            3: 500,  # Elbow joint
            4: 500,  # Wrist joint
            5: 500,  # Wrist rotation
            6: 500   # Gripper
        }
        
        self.fold_position = {
            1: 500,  # Base rotation
            2: 250,  # Shoulder down
            3: 300,  # Elbow in
            4: 300,  # Wrist curled
            5: 500,  # Wrist rotation
            6: 200   # Gripper closed
        }
        
        self.raised_position = {
            1: 500,  # Base rotation
            2: 700,  # Shoulder up
            3: 700,  # Elbow up
            4: 500,  # Wrist straight
            5: 500,  # Wrist rotation
            6: 500   # Gripper open
        }
        
        self.get_logger().info('Robot controller initialized')

    def move_arm(self, joint_positions: dict, duration: float = 1.0):
        """
        Move multiple arm joints simultaneously
        
        Args:
            joint_positions (dict): Dictionary mapping joint IDs to their target positions
            duration (float): Time in seconds for the movement to complete
        """
        msg = ServosPosition()
        msg.position_unit = 'pulse'
        msg.duration = duration
        
        for joint_id, position in joint_positions.items():
            servo = ServoPosition()
            # Convert joint_id to integer
            servo.id = int(joint_id)
            servo.position = float(position)
            msg.position.append(servo)
            
        self.arm_publisher.publish(msg)
        self.get_logger().info(f"Moving arm joints: {joint_positions}")

    def safe_move_robot(self, linear_speed: float, angular_speed: float, duration: float):
        """
        Move the robot base and immediately return to original position
        Duration is automatically limited to 0.5 seconds maximum
        
        Args:
            linear_speed (float): Forward/backward speed in m/s
            angular_speed (float): Rotational speed in rad/s
            duration (float): Time to move in seconds (capped at 0.5s)
        """
        # Cap duration at 0.5 seconds
        duration = min(duration, 0.5)
        
        # Forward movement
        twist = Twist()
        twist.linear.x = linear_speed
        twist.angular.z = angular_speed
        
        end_time = time.time() + duration
        while time.time() < end_time and rclpy.ok():
            self.movement_publisher.publish(twist)
            time.sleep(0.1)
        
        # Immediate return movement
        twist.linear.x = -linear_speed
        twist.angular.z = -angular_speed
        
        end_time = time.time() + duration
        while time.time() < end_time and rclpy.ok():
            self.movement_publisher.publish(twist)
            time.sleep(0.1)
        
        # Stop the robot
        twist.linear.x = 0.0
        twist.angular.z = 0.0
        self.movement_publisher.publish(twist)
        self.get_logger().info(f"Robot movement complete: linear={linear_speed}, angular={angular_speed}")

    def play_music(self, music_file: str):
        """
        Play music file in a separate thread
        
        Args:
            music_file (str): Path to the music file
        """
        try:
            pygame.mixer.music.load(music_file)
            pygame.mixer.music.play()
            self.get_logger().info(f"Playing music: {music_file}")
        except Exception as e:
            self.get_logger().error(f"Error playing music: {str(e)}")

    def execute_dance_from_json(self, json_file: str, music_file: str, start_delay: int = 3):
        """
        Execute dance movements from a JSON file generated by music analysis
        
        Args:
            json_file (str): Path to the JSON file containing dance commands
            music_file (str): Path to the music file to play
            start_delay (int): Delay in seconds before starting the dance
        """
        try:
            # Load JSON commands
            with open(json_file, 'r') as f:
                commands = json.load(f)
            
            if not commands:
                self.get_logger().error("No commands found in JSON file")
                return
            
            self.get_logger().info(f"Starting dance sequence in {start_delay} seconds...")
            for i in range(start_delay, 0, -1):
                self.get_logger().info(f"{i}...")
                time.sleep(1)
            
            # Start music in a separate thread
            music_thread = threading.Thread(target=self.play_music, args=(music_file,))
            music_thread.start()
            
            self.get_logger().info("DANCE STARTED!")
            start_time = time.time()
            
            # Execute each command
            for command in commands:
                target_time = start_time + command['timestamp']
                current_time = time.time()
                
                if current_time < target_time:
                    time.sleep(target_time - current_time)
                
                # Execute arm movement
                self.move_arm(command['arm_positions'], command['duration'])
                
                # Execute base movement with strafing
                if command['movement_type'] == 'forward':
                    # Add strafing based on energy level and beat number
                    if command['energy_level'] > 0.7 and command['beat_number'] % 4 == 0:
                        # High energy and every 4th beat - do a quick strafe
                        self.strafe_robot('left' if command['beat_number'] % 8 < 4 else 'right', 
                                        speed=0.3, 
                                        duration=command['duration'] * 0.5)
                    else:
                        self.safe_move_robot(0.2, 0.1, command['duration'])
                elif command['movement_type'] == 'return':
                    # Add strafing to return movements based on brightness
                    if command['brightness'] > 0.7 and command['beat_number'] % 3 == 0:
                        # High brightness and every 3rd beat - do a gentle strafe
                        self.strafe_robot('right' if command['beat_number'] % 6 < 3 else 'left',
                                        speed=0.2,
                                        duration=command['duration'] * 0.5)
                    else:
                        self.safe_move_robot(-0.2, -0.1, command['duration'])
                
                self.get_logger().info(
                    f"Executed {command['movement_pattern']} "
                    f"({command['movement_type']}) at {command['timestamp']:.1f}s"
                )
            
            # Wait for music to finish
            while pygame.mixer.music.get_busy():
                time.sleep(0.1)
            
            # Return to home position
            self.move_arm(self.home_position)
            self.safe_move_robot(0.0, 0.0, 0.1)
            self.get_logger().info("Dance complete!")
            
        except FileNotFoundError:
            self.get_logger().error(f"JSON file not found: {json_file}")
        except json.JSONDecodeError:
            self.get_logger().error(f"Invalid JSON format in file: {json_file}")
        except KeyboardInterrupt:
            self.get_logger().info("Dance interrupted by user")
            pygame.mixer.music.stop()
            # Ensure we return to home position
            self.move_arm(self.home_position)
            self.safe_move_robot(0.0, 0.0, 0.1)
        except Exception as e:
            self.get_logger().error(f"Error during dance: {str(e)}")
            pygame.mixer.music.stop()
            # Ensure we return to home position
            self.move_arm(self.home_position)
            self.safe_move_robot(0.0, 0.0, 0.1)

    def strafe_robot(self, direction: str, speed: float = 0.2, duration: float = 0.5):
        """
        Move the robot sideways (strafing) without forward/backward motion.
        
        Args:
            direction (str): 'left' or 'right' for strafing direction
            speed (float): Strafing speed in m/s (default: 0.2)
            duration (float): Time to move in seconds (default: 0.5)
        """
        # Cap duration at 0.5 seconds
        duration = min(duration, 0.5)
        
        # Create twist message for strafing
        twist = Twist()
        if direction.lower() == 'left':
            twist.linear.y = speed  # Positive Y for left strafe
        elif direction.lower() == 'right':
            twist.linear.y = -speed  # Negative Y for right strafe
        else:
            self.get_logger().error(f"Invalid direction: {direction}. Use 'left' or 'right'")
            return
        
        # Execute strafing movement
        end_time = time.time() + duration
        while time.time() < end_time and rclpy.ok():
            self.movement_publisher.publish(twist)
            time.sleep(0.1)
        
        # Return movement
        twist.linear.y = -twist.linear.y
        end_time = time.time() + duration
        while time.time() < end_time and rclpy.ok():
            self.movement_publisher.publish(twist)
            time.sleep(0.1)
        
        # Stop the robot
        twist.linear.y = 0.0
        self.movement_publisher.publish(twist)
        self.get_logger().info(f"Robot strafing complete: direction={direction}, speed={speed}")

def main(args=None):
    rclpy.init(args=args)
    node = RobotController()
    
    try:
        # Get the JSON file path and music file path from command line arguments
        import sys
        json_file = sys.argv[1] if len(sys.argv) > 1 else "jetrover_dance_commands.json"
        music_file = sys.argv[2] if len(sys.argv) > 2 else "music.wav"
        
        # Execute dance from JSON with music
        node.execute_dance_from_json(json_file, music_file)
        
    except Exception as e:
        node.get_logger().error(f'Error: {str(e)}')
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()